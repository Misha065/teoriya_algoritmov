import math

def floyd(W):
    n = len(W)
    D = [row[:] for row in W]

    for k in range(n):
        for i in range(n):
            for j in range(n):
                if D[i][j] > D[i][k] + D[k][j]:
                    D[i][j] = D[i][k] + D[k][j]

    return D


# === ПРАВИЛЬНА матриця суміжності ===
INF = math.inf

W = [
    [0,   INF, 7,   3,   INF, 6,   INF, INF],  # 1
    [INF, 0,   2,   9,   INF, 9,   INF, INF],  # 2
    [7,   2,   0,   INF, INF, INF, INF, 4],    # 3
    [3,   9,   INF, 0,   5,   INF, INF, INF],  # 4
    [INF, INF, INF, 5,   0,   4,   1,   INF],  # 5
    [6,   9,   INF, INF, 4,   0,   8,   7],    # 6
    [INF, INF, INF, INF, 1,   8,   0,   5],    # 7
    [INF, INF, 4,   INF, INF, 7,   5,   0]     # 8
]

# Запуск алгоритму
D = floyd(W)

# Вивід результату
print("Матриця найкоротших шляхів:")
for row in D:
    print(row)
