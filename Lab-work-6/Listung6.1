import heapq
from typing import Dict, List, Tuple, Any

INF = float('inf')

def dijkstra(adj: Dict[Any, List[Tuple[Any, float]]], source: Any):
    """
    adj: словник {v: [(u, w), ...], ...} — список суміжності
    source: стартова вершина
    повертає (dist, pred)
      dist: dict вершино->відстань від source
      pred: dict вершино->попередник у найкоротшому шляху (або None)
    """
    dist = {v: INF for v in adj}
    pred = {v: None for v in adj}
    dist[source] = 0.0

    # pq з елементами (distance, vertex)
    pq = [(0.0, source)]
    visited = set()

    while pq:
        d_u, u = heapq.heappop(pq)
        if u in visited:
            continue
        visited.add(u)

        # при великих графах: пропустити застарілі записи в pq
        if d_u > dist[u]:
            continue

        for v, w in adj[u]:
            # релаксація
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                pred[v] = u
                heapq.heappush(pq, (dist[v], v))

    return dist, pred

def reconstruct_path(pred: Dict[Any, Any], source: Any, target: Any) -> List[Any]:
    """Повертає шлях source -> target як список вершин (порожній, якщо немає шляху)."""
    if pred.get(target) is None and target != source:
        # якщо ціль недосяжна (і не рівна source)
        if target == source:
            return [source]
        return []
    path = []
    cur = target
    while cur is not None:
        path.append(cur)
        if cur == source:
            break
        cur = pred[cur]
    path.reverse()
    return path


example_adj = {
    'a': [('b', 3), ('d', 7)],
    'b': [('a', 3), ('c', 4), ('d', 2)],
    'c': [('b', 4), ('d', 4), ('e', 6)],
    'd': [('a', 7), ('b', 2), ('c', 4), ('e', 4)],
    'e': [('c', 6), ('d', 4)]
}

if __name__ == "__main__":
    source = 'a'  # підставити початкову вершину для твого варіанта
    dist, pred = dijkstra(example_adj, source)
    print("distances from", source)
    for v in sorted(dist):
        print(f"  {v}: {dist[v]}")
    print("\npredecessors:")
    for v in sorted(pred):
        print(f"  {v}: {pred[v]}")
    # приклад: побудувати шлях від a до e
    target = 'e'
    path = reconstruct_path(pred, source, target)
    print(f"\nshortest path {source} -> {target}:", path)
